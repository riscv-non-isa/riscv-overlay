
:toc:
:toclevels: 5
:sectnums:
:sectnumlevels: 5


= RISC-V Overlay “Software Standard Proposal” Version 0.1-draft-20201018



**Revision History**
[cols=",,,",options="header",]
|=============================================
|Revision |Date |Contents |Author(s)
|0.1 |Oct 07,2020 |Initial revision / Draft a
|Ronen Haen
 +
 Ofer Shinaar
 +
 Craig Blackmore

| | | |
|=============================================
{nbsp} +
{nbsp} +


**List of Figures**


{nbsp} +
{nbsp} +

**List of Tables**

link:#instrumentation-interface-hooks[Table 1 - Instrumentation interface hooks]

{nbsp} +
{nbsp} +

**Reference Documents**
[cols=",,,",options="",]
|========================================
|Item # |Document |Revision Used |Comment
|1 | | |
|========================================

{nbsp} +
{nbsp} +

[[_Toc507430300]]**Abbreviations**

[cols=",",options="",]
|===========================================
| Abbreviation | Description
| SW           | Software
| HW           | Hardware
| MMU          | Memory Management Unit
| OS           | Operation System
| LRU          | Least Recently Used
| RT-Engine    | Runtime Engine
| RTOS         | Real-Time Operating System
|===========================================

{nbsp} +
{nbsp} +

[[overview]]
== Overview

Physical memory is one of the most important resources in software programming, since the program runs on it. Some embedded systems have limited memory resources and as a result the total code footprint is often bigger than the available memory. To solve this problem, the program needs to use a technique to load executable code at runtime from virtual memory or to overwrite executable code that is not currently needed by the program.

On OS driven systems a virtual memory is very commonly used, the OS will use a HW MMU with direct mapping between virtual and the physical memory.

There is another technique that can be used to realize this paradigm in software without the need for special hardware. It is called ‘software overlay”.

The concept of arranging code in ‘code overlays’ is quite old but still valid these days to resolve the code size issue. For small embedded systems (like IoT) footprint and code size is critical. Those systems usually will not be driven by a large OS (e.g. Unix) and will not include a MMU.

An overlay represents a function or read-only data that by some scheme will be loaded into heap area when the SW requires it (e.g. for a function call). The overlay solution offers an advantage over HW, since the SW controls what needs to be loaded and when.

{nbsp} +
{nbsp} +

[[goals]]
== Goals

This document specifies the requirements for all the relevant SW entities needed to implement SW overlays. We expect changes in the toolchain and a requirement for a RT-Engine that handles calls/returns involving overlay functions and loads overlay functions/data as needed. The following requirements will lay a base for everyone to implement their own RT-Engine or toolchain support and/or take just part of the tools and integrate it with their own design.

The main goal of this standard is to make the SW developer experience an easy and smooth one. From the developer's point-of-view the request will be to just tag their designated overlay functions and overlay data with an attribute and the toolchain and RT-Engine will take care of the rest.

The implementation will be based on the RISC-V ISA and RISC-V tools but can be adopted to other targets.

{nbsp} +
{nbsp} +

[[methods-requirements]]
== Methods requirements

The following sections specify the requirements for:

1.  RT-Engine – SW module which is responsible for managing the overlay heap. This module is designated to be part of operational SW.
2.  Toolchain – broad collection of programming tools (e.g. compiler, linker, debugger, etc.) needed to develop SW applications.

[[run-time-engine]]
=== RT-Engine

[[general]]
==== General

1.  Since SW can be more flexible then HW, we should not use a direct mapping approach for overlays. For a small allocated overlay heap we can map any amount of code (within limits).
2.  Functions and read-only data can be in overlays.
3.  Functions and read-only data will be assigned to one or more overlay `groups`.
4.  The RT-Engine will be aware of the functions in the group and how to address them.
5.  The RT-Engine will manage the loading/eviction of groups via hooks to be implemented by the platform.
6.  The RT-Engine can run on a bare metal system or under a RTOS and therefore should be aware of RTOS usage to ensure it is thread safe, since any given thread can invoke overlay functions or use overlay data.

{nbsp} +
[[groups]]
==== Groups

A ‘Group’ is a collection of overlay functions and overlay data. We should use groups to minimize the necessity of loading/evicting a singular function from the overlay heap.

1.  Overlay group size can impact the RT-Engine and the toolchain so it must be selected pre-build.
2.  Overlay group size ranges from 512B – 4K for both functions and data.
3.  _Multi Group_ – an overlay function or overlay data can be resident in N groups. +
Example: foo(void) can be located in _Group~1~, Group~2~…, GroupN_

{nbsp} +
[[evict]]
==== Evict

Group eviction can be handled with similarity to HW cache concepts.

1.  Eviction resolution will be at `group` granularity, meaning we can evict N groups per demand.
2.  The search-algorithm for determining whether a group is loaded or not shall be defined at compile time.
3.  The RT-Engine will provide a “group lock/free” API mechanism to prevent specific groups from being evicted.

{nbsp} +
[[load]]
==== Load

The load area, “heap”, contains loaded overlay groups. It should have its own memory section definition, so that the RT-Engine and the toolchain can work on the same section.

1.  The heap area should be defined pre-build.
2.  The heap should have range limitation to be in sync with the RT-Engine and toolchain, that will be the minimum supported group size.
3.  We can have multiple heaps to be controlled by a single/multiple RT-Engine(s).
4.  A _Load-Function-Hook_ footnote:[Hook implementation will be the responsibility of the platform since only the platform knows how to implement them. +
Please refer to section *_3.1.6 Platform/Framework Hooks_*] will be provided to the user for executing the load operation itself.

{nbsp} +
[[invoke]]
==== Invoke

The RT-Engine will be the entity to invoke the overlay function.

1.  The RT-Engine should support invoking indirect function calls (i.e. calls via function-pointers)
2.  The search-algorithm is open to interpretation; we recommend to have at least one, for example LRU.
3.  After a function is loaded to the heap, the RT-Engine will be responsible for passing all requested arguments from the root caller to the callee.
+
Therefore, the RT-Engine will apply the ABI rules.
4.  Following the RISCV psABI, we should support #8 argument registers.

{nbsp} +
[[platformframework-hooks]]
==== Platform/Framework Hooks

Hooks implementation will be the responsibility of the platform since only the platform knows how to implement them. +
RT-Engine design may be dependent on platform resources (e.g. “enter critical” section) or may be able to leverage platform features to increase performance of the engine. +
For those the engine will need to expose API hooks to be provided by the platform/framework.

There are several types of hooks that need to be standardized so they can be used in any implementation:

[[load-function-hook]]
===== Load Function Hook

A hook triggered by the RT-Engine to request the load of a group.

The API will need to provide information which is understood by the engine and the user, +
AKA Overlay Static table (_link:#linker[Linker section: Overlay Static Table]_)

Example:

* Source: group location/referenced from the _‘Overlay Static Table’_
* Size of group
* Destination to load

[[error-hook]]
===== Error-Hook

On encountering an error, the RT-Engine will call the Error-Hook.

[[instrumentation-interface-hooks]]
===== Instrumentation interface hooks

Instrumentation is needed for analysis, which can be used to improve the performance of overlay function calls.
For example: user can catch a sequence of overlay-function-calls, from the instrumentation, and according to the result he can encapsulate the functions to a specific group.

.Instrumentation interface hooks
[cols="1%,30%,50%",options="header,,autowidth",]
|======================================================================================================================
| |Instrumentation name |Description
|1.|Invoke callee + Load |Load overlay function and invoke it
|2.|Invoke caller (return) + load |When returning to an overlay function, and re-loading of the ‘caller’ is needed
|3.|Invoke callee + No load |The callee function is already loaded, we just need to invoke it
|4.|Invoke caller (return) + No load |When returning from an overlay function and re-loading of the ‘caller’ is needed
|======================================================================================================================


[[rtos-hooks]]
===== RTOS hooks

On RTOS based system, the RT-Engine will provide hooks to protect its critical sections. Those hooks will be implemented by the user.

{nbsp} +

[[rtos]]
==== RTOS

The RT-Engine should support a system bare metal design and/or RTOS system design.

1.	The implementation with/without RTOS should be a build time option.
2.	If RTOS is supported, the RT-Engine should be thread safe and not block other threads due to overlay operations.
3.	Blocking can be acceptable for short critical sections and only with inherent operations (e.g. mutex).
4.	The RT-Engine should be agnostic to any specific RTOS, therefore hooks should be provided _(link:#rtos-hooks[RTOS hooks])_.
5.	Load operations should lock the designated memory region in the heap, to prevent a case where a higher priority task will take the region from the current running task.

{nbsp} +
{nbsp} +

[[toolchain]]
=== Toolchain

The toolchain; broad collection of programming tools (e.g. compiler, linker, debugger, and so forth...) needs to be integrated with the overlay standard, as it impacts the native usage of overlay.
The compiler, the linker, and the debugger needs to support overlay mechanism in order for the user, to use overlay functions and debug them. Following are the module-requirements per tool.

{nbsp} +

[[compiler]]
==== Compiler

Main compiler demands are related to generating a sequence code to enter the RT-Engine whenever the running code “hit” an overlay symbol, which can be data usage or function call.

1.  Compiler needs to generate code for any related overlay usage, the sequence will lead to entering to the RT-Engine were it will manage the process of loading, evicting, etc…
2.  User will need to add a designated attribute to its target overlay function for the compiler to emits the designated sequence for example: "\___attribute___ (overlaycall)"
3.  Types of related overlay use cases:
a.  Direct call – just calling to the overlay function
b.  Indirect call – call is via function pointer
c.  Data – data which is marked as overlay should be reference with the same sequence to enter the RT-Engine' so it can load/call it when needed
4.  We probably need to allocate few core registers to be used only for the engine. Those registers should also be addressed by compiler and debugger. This way those registers forming a spec/handshake between compiler, RT code and debugger.
+
The toolchain will need to be rebuild with "awareness" that it can not use all the core registers.
5.  The compiler should pass a descriptor/token to the RT-Engine via the 'entry' sequence. +
The descriptor will be materialized at linking time.
6.  A related debug information should be aligned with the compiler overlay scheme.

{nbsp} +

[[linker]]
==== Linker

1.  Overlay symbols cannot be referenced with memory address, since they are not part of the physical memory. Therefor we should have a descriptor/token to describing the overlay symbol, for example for which group it is related, offset to the function? etc ...
2.  The linker will get all the necessary data for overlay symbols from: objects, linker script and from a the linker input flags.
3.  Shall create an overlay section for all overlay symbols in the program (user define it on the code it self, by the attribute).
4.  Symbols are to be assigned to *Groups* on target-link time, as the linker have system visibility for all text and ro-data.
5.  Shall have the ability to encapsulate functions and read-only data to overlay groups.
6.  There should be an *_"overlay area"_* to holds all the groups in the program. This area is not for execution, it is for linker to treat overlay function as regular functions: address allocation, optimization etc…
7.  Multi-group
+
The linker should deal with overlay symbols which can be resident in more then one group:

a. Overlay function can be resident in more than one group
b. Overlay read-only data can be resident in more than one group

8.  Overlay Static Table
a. The linker shall create a group-offset-table to hold all the overlay-groups offsets, each entry index in the table represents and overlay group. Each entry content represent the a zero base offset of the group.
b. Overlay group ID (numbers) assignment should be aligned with the table.
c. This table can be access by the FW on RT, or by another utility, to be used as a mapping to locate an overlay group.
d. Table shall be aligned with the *_"overlay area"_* so it can be referenced by the FW (e.g. for load operation), or other utilities, to find the requested group.
9.  Overlay group size ranges from 512B – 4K for both functions and data


NOTE: This table is targeted to be a spec between the running code and the low level driver for loading the overlay function (per group). Since the table is part of the code, the developer can manage it and allocated a placeholder for the overlay groups/functions in the storage for example (storage refers to any SW I/F that can fetch the code).


{nbsp} +

[[debugger]]
==== Debugger

Since our goal is to provide comfortable experience to the SW developers we need to support it with good debugging options. Adding SW break points, doing step-inst, etc… are key features which the debugger needs to address on an overlay system, where overlay functions can be mapped or unmapped (loaded/unloaded).

.  The debugger should give the overlay functions the same debugging capabilities as on none overlay function, like step, step-inst, skip, etc…
.  Debugger should hold a trace history (for call-stack) and include the RT-Engine calls as well.
.  Overlay RT-Engine awareness:
..  To give comfortable experience we should have an option to “skip” the RT-Engine operations and move directly to the function. E.g. if doing ”step-in” myOverlayfoo() we should see next PC in the beginning of myOverlayFo() and not in the RT-Engine'.
..  Likewise, we want to disable this “skip” option in case we want to debug the RT-Engine.
..  The same logic will happen if we want to return to an overlay function.

.  The debugger will be agnostics to the existence of RTOS, this means a context switch can happen in during overlay operation and the debugger should hold a valid sequence. This can be achieved by "spec handshake" between RT-Engine data base and the debugger.
.  Changes in the debugger should be generic in such a way that all related “spec handshake” will be in external file to hook into the debugger.
. We shall have debug information for overlay functions, that information should be symmetric if a function is placed in several groups (*_multi group_*).
