
:toc:
:toclevels: 5
:sectnums:
:sectnumlevels: 5


= RISC-V Overlay “Software Standard Proposal” Version 0.1-draft-20201018



**Revision History**
[cols=",,,",options="header",]
|=============================================
|*_Revision_* |*_Date_* |*_Contents_* |*_Author(s)_*
|0.1 |Oct 07,2020 |Initial revision / Draft a
|Ronen Haen
 +
 Ofer Shinaar
 +
 Craig Blackmore

| | | |
|=============================================
{nbsp} +
{nbsp} +


**List of Figures**


{nbsp} +
{nbsp} +

**List of Tables**

link:#instrumentation-interface-hooks[Table 1 - Instrumentation interface hooks]

{nbsp} +
{nbsp} +

**Reference Documents**
[cols=",,,",options="",]
|========================================
|Item # |Document |Revision Used |Comment
|1 | | |
|========================================

{nbsp} +
{nbsp} +

[[_Toc507430300]]**Abbreviations**

[cols=",",options="",]
+|===========================
+|Abbreviation |Description
+|SW           |Software
+|HW           |Hardware
+|MMU          |Memory Management Unit
+|LRU          |Least Recently Used
+|OS           |Operation System
+|RT           |RunTime or RealTime
+|RT-Engine    |Runtime Engine
+|RTOS         |Runtime Operation System
+|R/O or RO    |Read Only
|===========================

{nbsp} +
{nbsp} +

[[overview]]
== Overview

Physical memory is one of the most important resources in sw programming since the program runs on it. Some embedded systems have limited memory resources and as a result, the total code footprint is bigger than the available memory. To solve this problem, the program needs to use a technique to load executable code on run time from virtual memory or to overrun executable code which is not needed anymore by the program.

On OS driven systems a virtual memory is very commonly used, the OS will use HW MMU with a direct mapping between virtual and the physical memory.

There is another technique to be used for solving this paradigm without the usage of HW. It is called ‘software overlay”.

The concept of arranging code in ‘code overlays’ is quite old but still valid these days to resolve the code size issue. For small embedded systems (like IoT) footprint and code size is critical. Those systems usually will not be driving by large OS (unix alike) and will not involve MMU.

Overlay represents an overlay function/segment which by terms, will be loaded to the heap area, and executed by the SW when been called. The overlay solution emphasizes an advantage over HW, since the software controlling what needs to be loaded and when.

{nbsp} +
{nbsp} +

[[goals]]
== Goals

This document specifies the requirements for all the relative software entities, which are needed to participate in the implementation of the sw-overlay. We expected changes in the toolchain and on the RT code which is driving the loading and invoking the overlay calls. The following requirements will lay a base for everyone to implement their own RT Engine or toolchain or/and take just part of the tools and integrate it into their own design.

The main goal of this standard is to make the software developer experience an easy and smooth one. From the developer point-of-view the request will be to just tag (attribute) his designated overlay functions and the toolchain and the RT-Eng will take care of the rest.

The implementation will be based on RISC-V ISA and RISC-V tools but can be adapted to other targets.

{nbsp} +
{nbsp} +

[[methods-requirements]]
== Methods requirements

The following sections specify the requirements for:

1.  Run Time Engine – SW module which is responsible for managing the overlay heap. This module is designated to be part of operational SW
2.  Toolchain – a broad collection of programming tools (e.g. compiler, linker, debugger, etc.) which needs to develop SW applications.

[[run-time-engine]]
=== Run Time Engine

[[general]]
==== General

1.  Since the software can be more flexible than HW, we should not use a direct mapping approach for overlay. For a small allocated overlay heap, we can map any amount of code.
2.  Functions and const-data can be in overlay
3.  Functions/Const-data will be encapsulated `groups`.
4.  Engine will be aware of the functions in the group, and will be aware of how to address them.
5.  Engine will manage load/evict of groups by providing hooks to be implemented  by the platform.
6.  Can run on a bare metal system or under RTOS. Engine should be aware of RTOS usage so it must be thread safe – any given thread can invoke overlay functions.

{nbsp} +
[[groups]]
==== Groups

A ‘Group’ is a collection of overlay functions. We should use groups to minimize the necessity of loading/evicting a singular function from ram-heap.

1.  Overlay group size can impact the RT Engine and the Toolchain so it must be selected pre-build
2.  Overlay group size ranges from 512B – 4K for both functions and const-data.
3.  Group size will be decided in advanced by the developer, and we will provided to at link-time.
4.  _Multi Group_ – a function symbol can be resident in N groups. +
Example: foo(void) can be located in _Group~1~, Group~2~…, GroupN_

{nbsp} +
[[evict]]
==== Evict

Evict of groups can be handled with similarity to HW cache concepts.

1.  Evict resolution will be a `group`, meaning we can evict N groups per demand.
2.  The Search-algorithm for determining whether a group is loaded or not shall be defined at compile time.
3.  RT Eng will provide “group lock/free” API mechanism to prevent a group from been evicted

{nbsp} +
[[load]]
==== Load

The load area, “heap”, is been used for containing the loaded overlay groups. It should have its own memory section definition so that the RT engine and the toolchain can work on the same section

1.  Heap area should be defined pre-build
2.  Heap should have range limitation to be in sync with the RT Engine and toolchain. Heap minimum size should not be the smaller then the maximum pre-defined overlay group size.
3.  We can have multiple Heaps to be controlled by signal/multiply RT Engine/s
4.  A _Load-Function-Hook_ footnote:[Hooks implantation will be under platform responsibility since only the platform knows how to implement them. +
Please referee to section *_3.1.6 Platform/Framework Hooks_*] will be provided to the user for executing the load operation itself

{nbsp} +
[[invoke]]
==== Invoke

The RT Engine will be the entity to call the overlay function – invoke it.

1.  The engine should support invoke indirect function calls (also known as function-pointers)
2.  Search-algorithm is open to interpretation; we recommend having at least one, for example, LRU.
3.  After the function was loaded to the heap, the RT-Eng will be responsible to pass all requested arguments from the root caller to the designated invocation.
+
Therefore the RT-Eng will apply the ABI rules
4.  Following RISCV psABI we should support #8 arguments

{nbsp} +
[[platformframework-hooks]]
==== Platform/Framework Hooks

Hooks implantation will be under platform responsibility since only the platform knows how to implement them. +
RT Eng design may be based on platform resources, like “enter critical” section, or maybe to leverage platform resources to increase performance in the engine. +
For those, the engine will need to expose API hooks to be provided by the platform/framework.

There are several types of hooks that need to be standardized so it can be used on any implementation:

[[load-function-hook]]
===== Load Function Hook

A hook which will be trigger by the RT-Engine to request a load of group

The API will need to provide information which is understood by the engine and the user, +
AKA Overlay Static table (_link:#linker[Linker section: Overlay Static Table]_)

Example:

* Source: group location/referenced from the _‘Overlay Static Table’_
* size of group
* destination to load

[[error-hook]]
===== Error-Hook

Error in the RT eng will call the Error-Hook

[[instrumentation-interface-hooks]]
===== Instrumentation interface hooks

Instrumentation is needed for analysis, which can be used to improve the performance of overlay function calls.
For example, a user can catch a sequence of overlay-function-calls, from the instrumentation, and according to the result, he can encapsulate the functions to a specific group.

.Instrumentation interface hooks
[cols="1%,30%,50%",options="header,,autowidth",]
|======================================================================================================================
| |Instrumentation name |Description
|1.|Invoke callee + Load |Load overlay function and invoke it
|2.|Invoke caller (return) + load |When returning to an overlay function, and re-loading of the ‘caller’ is needed
|3.|Invoke callee + No load |The callee function is already loaded, we just need to invoke it
|4.|Invoke caller (return) + No load |When returning from an overlay function and re-loading of the ‘caller’ is needed
|======================================================================================================================


[[rtos-hooks]]
===== RTOS hooks

On RTOS based system, the RT-Eng will provide hooks to protect its critical sections. Those hooks will be implemented by the user.

{nbsp} +

[[rtos]]
==== RTOS

The RT Eng should support a system bare metal design and/or RTOS system design.

1.  The implementation with/without RTOS should be a compile-time option.
2.  If RTOS is supported, the RT Eng should be “thread save” and not blocking other threads due to overlay operations.
3.  Blocking can be acceptable for short critical section and only with inherent operations (e.g. mutex)
4.  The RT-Eng should be agnostics to any specific RTOS, therefore hooks should be provided _(link:#rtos-hooks[RTOS hooks])_
5.  Load operation should lock the designated memory region in the heap, to prevent a case were higher priority task will take the region from the current running task.

{nbsp} +
{nbsp} +

[[toolchain]]
=== Toolchain

The toolchain; broad collection of programming tools (e.g. compiler, linker, debugger, and so forth...) needs to be integrated with the overlay standard, as it impacts the native usage of an overlay.
The compiler, the linker, and the debugger need to support the overlay mechanism  for the user, to use overlay functions and debug them. The following are the module-requirements per tool.

{nbsp} +

[[compiler]]
==== Compiler

Main compiler demands are related to generating a sequence code to enter the RT Engine whenever the running code “hit” an overlay symbol, which can be data usage or function call.

1.  Compiler needs to generate code for any related overlay usage, the sequence will lead to entering the RT Engine where it will manage the process of loading, evicting, etc…
2.  User will need to add a designated attribute to its target overlay function for the compiler to emits the designated sequence for example: "\___attribute___ (overlaycall)"
3.  Types of related overlay use cases:
a.  Direct call – just calling to the overlay function
b.  Indirect call – call is via a function pointer
c.  Data – data which is marked as overlay should be reference with the same sequence to enter the RT Eng' so it can load/call it when needed
4.  We probably need to allocate a few core registers to be used only for the engine. Those registers should also be addressed by the compiler and debugger. This way those registers forming a _RT-Eng-Debugger-handshake_ between compiler, RT code and debugger.
+
The toolchain will need to be rebuilt with "awareness" that it can not use all the core registers.
5.  The compiler should pass a descriptor/token to the RT Engine via the 'entry' sequence. +
The descriptor will be materialized at linking time.
6.  A related debug information should be aligned with the compiler overlay scheme.

{nbsp} +

[[linker]]
==== Linker

1.  Overlay symbols cannot be referenced with a memory address, since they are not part of the physical memory. Therefore we should have a descriptor/token to describing the overlay symbol, for example for which group it is related, offset to the function? etc ...
2.  The linker will get all the necessary data for overlay symbols from objects, linker script, and from the linker input flags.
3.  Shall create an overlay section for all overlay symbols in the program (user define it on the code itself, by the attribute).
4.  Symbols are to be assigned to *Groups* on target-link time, as the linker has system visibility for all text and ro-data.
5.  Shall have the ability to encapsulate functions and R/O Data to overlay groups.
6.  There should be an *_"overlay area"_* to holds all the groups in the program. This area is not for execution, it is for the linker to treat overlay function as regular functions: address allocation, optimization, etc…
7.  Multi-group
+
The linker should deal with overlay symbols which can be resident in more than one group:

a. Overlay function can be resident in more than one group
b. Overlay RO-Data can be resident in more than one group

8.  Overlay Static Table
a. The linker shall create a group-offset-table to hold all the overlay-groups offsets, each entry index in the table represents an overlay group. Each entry content represents a zero base offset of the group.
b. Overlay group ID (numbers) assignment should be aligned with the table.
c. This table can be accessed by the FW on RT, or by another utility, to be used as a mapping to locate an overlay group.
d. Table shall be aligned with the *_"overlay area"_* so it can be referenced by the FW (e.g. for load operation), or other utilities, to find the requested group.
9.  Overlay group size ranges from 512B – 4K for both functions and data


NOTE: This table is targeted to be a spec between the running code and the low level driver for loading the overlay function (per group). Since the table is part of the code, the developer can manage it and allocated a placeholder for the overlay groups/functions in the storage for example (storage refers to any software I/F that can fetch the code).


{nbsp} +

[[debugger]]
==== Debugger

Since our goal is to provide a comfortable experience to the software developers we need to support it with good debugging options. Adding SW breakpoints, doing step-inst, etc… are key features that the debugger needs to address on an overlay system, where overlay functions can be mapped or unmapped (loaded/unloaded).

.  The debugger should give the overlay functions the same debugging capabilities as on none overlay function, like step, step-inst, skip, etc…
.  _RT-Eng-Debugger-handshake:_ The debugger and the RT-Eng will communicate during run-time.
The information pass from the RT-Eng to the debugger will contain the status of the loaded/unloaded (mapped/unmapped) overlay groups.
.  The Debugger should hold a trace history (for call-stack) and include the RT-Eng calls as well.
.  Overlay RT-Eng awareness:
..  To give a comfortable experience we should have an option to “skip” the RT-Eng operations and move directly to the function. E.g. if doing ”step-in” myOverlayfoo() we should see the next PC at the beginning of myOverlayFo() and not in the RT-Eng'.
..  Likewise, we want to disable this “skip” option in case we want to debug the RT-Eng.
..  The same logic will happen if we want to return to an overlay function.

.  The debugger will be agnostics to the existence of RTOS, this means a context switch can happen during overlay operation and the debugger should hold a valid sequence.
.  Changes in the debugger should be generic in such a way that all related _“RT-Eng-Debugger-handshake”_ will be in an external file to hook into the debugger.
. We shall have to debug information for overlay functions, that information should be symmetric if a function is placed in several groups (*_multi group_*).
